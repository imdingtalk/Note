<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>snoopy</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content><meta name=generator content="Hugo 0.83.1"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel=stylesheet href=/dingtalk.pub/ananke/dist/main.css_5c99d70a7725bacd4c701e995b969fea.css><link href=dingtalk.pub/post/index.xml rel=alternate type=application/rss+xml title=snoopy><link href=dingtalk.pub/post/index.xml rel=feed type=application/rss+xml title=snoopy><meta property="og:title" content="Posts"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="dingtalk.pub/post/"><meta itemprop=name content="Posts"><meta itemprop=description content><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content></head><body class="ma0 avenir bg-near-white"><header><div class="pb3-m pb6-l bg-black"><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=dingtalk.pub/ class="f3 fw2 hover-white no-underline white-90 dib">snoopy</a><div class="flex-l items-center"></div></div></nav><div class="tc-l pv3 ph3 ph4-ns"><h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">Posts</h1></div></div></header><main class=pb7 role=main><article class="pa3 pa4-ns nested-copy-line-height nested-img"><section class="cf ph3 ph5-l pv3 pv4-l f4 tc-l center measure-wide lh-copy mid-gray"></section><aside class="flex-ns flex-wrap justify-around mt5"><div class="relative w-100 w-30-l mb4 bg-white"><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>October 16, 2019</div><h1 class="f3 near-black"><a href=dingtalk.pub/post/2878743/ class="link black dim">记一次虚拟机重启后网卡启动失败的问题，RTNETLINK answers: File exists</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">问题描述  在玩k8s的时候，改了一个api的静态配置文件，死活启动不起来静态pod了，api一直起不来，尝试万能重启大法，重启后，额，连接不上虚拟机了，登录VC ,发现，服务器的网卡没有IP 排查和处理 首先尝试，手动重启，么有效果  想到之前遇到过的坑，是不是/etc/udev/rules.d/70-persistent-net.rules  文件导致的，查看之，里面并没有有效的记录，所以，应该不是这个导致的 老实看日志吧 ,主要报错如下  #systemctl status network .... RTNETLINK answers: File exists RTNETLINK answers: File exists RTNETLINK answers: File exists .... 额，别人家的遇到这个可以像我的第二个想法那样处理了呀，为毛我不行，
疯狂ifup ifdown&mldr;.然鹅并没有什么用 处理 再次检查网卡配置文件，，新添加了一行 ##在原配置文件新添加一行， DEVICE=eth0 #ifup eth0 ## 然后，尼玛，网卡就启动起来了，起来，，，了。 为毛我之前没有DEVICE这行，愉快重启那么多次么有问题？ WHY 在网卡启动过程中，新添加网卡的时候，识别的是DEVICE字段，而不是NAME字段（只是网络连接的名字），好比我的一个WiFi，无线网卡就那么一个，名字唯一，但是ssid可以有很多，随便娶。。我的配置文件之前是没有DEVICE字段的，导致/etc/udev/rules.d/70-persistent-net.rules 文件里面也没有对应的网卡信息，所以没得玩，而开机的时候需要从 ifcfg-eth0中获取DEVICE的名字，但是我没配置，所以没有启动起来网卡</div></div></div><div class="relative w-100 w-30-l mb4 bg-white"><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>October 15, 2019</div><h1 class="f3 near-black"><a href=dingtalk.pub/post/2857446/ class="link black dim">NGINX禁止使用IP访问，防止恶意域名解析</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">什么是恶意域名解析 外部未知的域名持有者，将域名解析到非其所持有的服务器公网IP上，间接或直接造成损害他人利益的行为。 暗箭伤人 域名的恶意解析，可以用于借刀杀人。 这个手法很骚，轻则可以将对手的SEO排名拉低，重则可以让工信部封杀其站点。 **具体实现条件如下： **
未备案的域名或已被接入工信部黑名单的域名 获取要攻击的站点，其源服务器使用的公网IP 确认要攻击的网站80端口和443端口可以直接用IP直接访问 将黑域名解析到该公网IP **危害如下： **
不同域名解析到同个站点，真身域名权重被降低，SEO排名被假域名挤占  非法域名解析，导致源服务器被工信部封杀，网站停止服务 解决方法 将无效域名的HTTP请求，全部拒绝响应
新加一个server段如下： server { listen 443 default_server; listen 80 default_server; #筛选无效域名 server_name _; #直接返回错误码的方式 return 404; #rewrite 的方式(比较友好) #rewrite ^(.*)$ https://xxx.com/40x.html permanent; #日志可选，可以看看哪些非法访问 #access_log off; ssl_certificate "/usr/local/openresty/nginx/ssl/demofullchain.cer"; ssl_certificate_key "/usr/local/openresty/nginx/ssl/demo.dingtalk.pub.key"; }</div></div></div><div class="relative w-100 w-30-l mb4 bg-white"><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>October 11, 2019</div><h1 class="f3 near-black"><a href=dingtalk.pub/post/2809327/ class="link black dim">k8s网络小探</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">容器网络 在说k8s的网络之前，先熟悉下容器的网络模式。
docker会在宿主机启动一张网卡 docker0 容器通过Veth Pair 连接容器和docker0，Veth Pair相当于网线 docker0 在容器通信的过程中相当于二层交换机 容器会有默认路由指向docker0 当一个容器试图连接到另外一个宿主机时，首先经过 docker0 网桥出现在宿主机上。然后根据宿主机路由规则路由 #使用以下命令查看网桥的连接情况 [root@rbtnode1 ~]# brctl show bridge name bridge id STP enabled interfaces br-5bc39396abe2 8000.024219350061 no veth1a289de veth3504d23 docker0 8000.0242d50f88b5 no veth210c0a2 ... [root@rbtnode1 ~]# ip ad | grep veth 16: vethwe-datapath@vethwe-bridge: &lt;BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1376 qdisc noqueue master datapath state UP group default 17: vethwe-bridge@vethwe-datapath: &lt;BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1376 qdisc noqueue master weave state UP group default 2631: veth210c0a2@if2630: &lt;BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue master docker0 state UP group default 2682: veth3504d23@if2681: &lt;BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue master br-5bc39396abe2 state UP group default ##这里可以看到我们宿主机存在一个虚拟网卡 veth3504d23 ，他一端连接的是docker0，另一端则连接的是容器的eth0 ##其他的容器在创建的时候也会发生同样的事 ##相当于启动容器后，会有一“网线”，连接docker0和容器，由于都连接同一个交换机，默认情况下，各个容器间可以直接互通 容器的通信示意图（源自张磊）：k8s网络的发展 在docker的默认配置下，容器的网络没法处理跨主机网络的互相通信。为了解决跨主机通信的问题，社区出现了一些方案 flannel UDP 模式 而 UDP 模式，是 Flannel 项目最早支持的一种方式，也是性能最差的一种模式，如今已被弃用，但是对我们理解集群的网络还是有帮助的 该模式的主要通信过程如下</div></div></div><div class="relative w-100 w-30-l mb4 bg-white"><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>September 16, 2019</div><h1 class="f3 near-black"><a href=dingtalk.pub/post/2622524/ class="link black dim">aria2c 不限速下载服务配置 RPC</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">介绍 aria2是一个轻量级的多协议和多源，跨平台下载实用程序，在命令行中运行。它支持HTTP / HTTPS，FTP，SFTP，BitTorrent和Metalink。https://aria2.github.io/ 安装和使用 安装 在epel源有打包好的包可以直接安装
yum install aria2 -y 使用 Download from WEB: $ aria2c http://example.org/mylinux.iso Download from 2 sources: $ aria2c http://a/f.iso ftp://b/f.iso Download using 2 connections per host: $ aria2c -x2 http://a/f.iso BitTorrent: $ aria2c http://example.org/mylinux.torrent BitTorrent Magnet URI: $ aria2c 'magnet:?xt=urn:btih:248D0A1CD08284299DE78D5C1ED359BB46717D8C' Metalink: $ aria2c http://example.org/mylinux.metalink Download URIs found in text file: $ aria2c -i uris.txt RPC的用法 使用rpc的方式可以扩展该下载工具为专用下载工具，可以被其他的下载软件调用，如 pandownload创建新的配置文件 vim ~/.aria2/aria2.conf ## '#'开头为注释内容, 选项都有相应的注释说明, 根据需要修改 ## ## 被注释的选项填写的是默认值, 建议在需要修改时再取消注释 ## ## 文件保存相关 ## # 文件的保存路径(可使用绝对路径或相对路径), 默认: 当前启动位置 dir=~/downloads # 启用磁盘缓存, 0为禁用缓存, 需1.</div></div></div><div class="relative w-100 w-30-l mb4 bg-white"><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>September 2, 2019</div><h1 class="f3 near-black"><a href=dingtalk.pub/post/2315911/ class="link black dim">基于drone的CI-CD实践</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">介绍 组件 drone：自助式的CI/CD交互平台，提供开源版本，可私有部署 helm：k8s的包管理器 k8s：云原生.. gitlab：代码仓库 maven/dockerhub：镜像仓库 流程 安装 安装方式推荐docker方式，一条命令完事儿，drone需要安装drone-server和drone-agent，参考：https://docs.drone.io/installation/gitlab/ 安装server： docker run \ --volume=/var/run/docker.sock:/var/run/docker.sock \ --volume=/var/lib/drone:/data \ --env=DRONE_GIT_ALWAYS_AUTH=false \ --env=DRONE_GITLAB_SERVER=http://gitlab.xxx.com \ --env=DRONE_GITLAB_CLIENT_ID=9d71bdccd11156913a475891ab082f61677aae816e40911896cb82c17fcfc87e \ --env=DRONE_GITLAB_CLIENT_SECRET=8039aff4d23560355e76e7855b409399c119fdb4005c9d02a2291bfe05d5b6da \ --env=DRONE_RUNNER_CAPACITY=2 \ --env=DRONE_SERVER_HOST=drone.test.com \ --env=DRONE_USER_CREATE=username:xxx,admin:true\ --env=DRONE_SERVER_PROTO=http \ --env=DRONE_TLS_AUTOCERT=false \ --env=DRONE_USER_FILTER=xxx \ --env=DRONE_RPC_SECRET=b00553e8d490f13d296fa0f8a3bdd630 \ --publish=80:80 \ --publish=443:443 \ --restart=always \ --detach=true \ --name=drone \ drone/drone:1.</div></div></div><div class="relative w-100 w-30-l mb4 bg-white"><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>August 8, 2019</div><h1 class="f3 near-black"><a href=dingtalk.pub/post/2309330/ class="link black dim">helm本地仓库实践</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">介绍 Helm是查找，共享和使用为Kubernetes构建的软件的最佳方式 安装 直接在github获取： https://github.com/helm/helm 在集群中初始化 首先声明rbac vim rbac-config.yaml
apiVersion: v1 kind: ServiceAccount metadata: name: tiller namespace: kube-system --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: tiller roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: cluster-admin subjects: - kind: ServiceAccount name: tiller namespace: kube-system kubectl apply -f ``rbac-config.yaml使用阿里云的仓库初始化 helm init --stable-repo-url https://apphub.aliyuncs.com/ --service-account tiller 初始化后，在kube-system里面会创建一个deploy，但是里面的镜像是谷歌的，需要手动改一下 kubectl edit deployments. -n kube-system tiller-deploy #在helm -v3中删除了tiller组件 --- ... spec: automountServiceAccountToken: true containers: - env: - name: TILLER_NAMESPACE value: kube-system - name: TILLER_HISTORY_MAX value: "0" image: imdingtalk/tiller:v2.</div></div></div><div class="relative w-100 w-30-l mb4 bg-white"><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>August 2, 2019</div><h1 class="f3 near-black"><a href=dingtalk.pub/post/2251281/ class="link black dim">HSTS域名实践</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">介绍 大家比较熟悉的是https，在传输数据之前，https会验证客户和服务器直接的信任关系，通过握手来确认这种认证，但是当网站传输协议从 HTTP 到 HTTPS 之后，数据传输真的安全了吗？ 由于用户习惯，通常准备访问某个网站时，在浏览器中只会输入一个域名，而不会在域名前面加上 http:// 或者 https://，而是由浏览器自动填充，当前所有浏览器默认填充的都是http://。一般情况网站管理员会采用了 301/302 跳转的方式由 HTTP 跳转到 HTTPS，但是这个过程总使用到 HTTP 因此容易发生劫持，受到第三方的攻击。如图： 配置 在443的server段添加如下配置： add_header Strict-Transport-Security "max-age=63072000; includeSubdomains; preload"; 在80端口的server端添加重定向：
return 301 https://$server_name$request_uri; 重启服务后的效果 启用hsts后，浏览器还是存在首次访问使用HTTP请求的情况，可以在这里 ，把我们的域名添加到浏览器的预加载里面，浏览器遇到该域名的时候即可实现首次访问的时候就使用https的方式请求，进一步提高安全性 问题 在使用通配的证书的时候，开启HSTS，在使用HTTP请求网站的时候，由于HSTS需要验证，在请求的时候，浏览器会直接使用https发起请求，如我们要访问http://dingtalk.pub;浏览器会直接使用https发起访问，即使用https://dingtalk.pub发起访问，本来如果正常访问http://dingtalk.pub，服务器会直接重定向为https://www.dingtalk.pub;这样不会引起证书问题，但是启用HSTS后，会存在我们的通配证书对根域名 dingtalk.pub的不信任问题，这个，还不知道怎么处理，后面再跟进这个问题将直接导致谷歌浏览器不接受这样不安全的访问 关于这个问题的处理 ~~ ~~额，之前没有发现一个证书是可以颁发给多个域名的，同时颁发给dingtalk.pub和*.dingtalk.pub就可以了嘛，蠢了蠢了;后面再测试，甚至可以颁发给不同的根域
#生成证书的时候这样生成 acme.sh --issue --dns dns_ali -d dingtalk.pub -d *.dingtalk.pub -d *.edgon.cn #安装证书 acme.sh --install-cert -d dingtalk.pub -d *.dingtalk.pub --key-file /etc/nginx/ssl/dingtalk.key --fullchain-file /etc/nginx/ssl/dingtalk.cer --reloadcmd "systemctl restart nginx " server { listen 443; ..... ssl_certificate "/etc/nginx/ssl/dingtalk.</div></div></div><div class="relative w-100 w-30-l mb4 bg-white"><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>July 31, 2019</div><h1 class="f3 near-black"><a href=dingtalk.pub/post/2244982/ class="link black dim">基于acme的域名通配证书配置和自动续期</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">简介 在我们的环境中要求，所有的请求都使用https的方式，如果购买商用证书，感觉成本很过分。于是测试使用let&rsquo;s encrypt wildcard的方式来实现
工具介绍 http://acme.sh 一个实现ACME客户端协议的纯Unix shell脚本，用于各种证书的生成。 安装和使用 这个在项目的readme已经很完善了，结合自己的使用，来简要说明下 安装很简单, 一个命令:
curl https://get.acme.sh | sh 生成证书 我这里使用的阿里的域名，使用的dnsapi方式验证 首先去获取API的的key和secret，https://ak-console.aliyun.com/#/accesskey 或 https://ram.console.aliyun.com/permissions 给与dns权限 然后选择该有权限的用户，创建新的accessKey 使用刚刚获取的key来配置acme需要的信息 export Ali_Key="sdfsdfsdfljlbjkljlkjsdfoiwje" export Ali_Secret="jlsdflanljkljlfdsaklkjflsa" #Ali_Key和Ali_Secret将保存在〜/.acme.sh/account.conf中，并在需要时重复使用。 #颁发证书 acme.sh --issue --dns dns_ali -d *.demo.dingtalk.pub #建议颁发证书的时候包含根域名 acme.sh --issue --dns dns_ali -d dingtalk.pub -d *.dingtalk.pub acme.sh --issue --dns dns_ali -d *.demo.dingtalk.pub -d demo.dingtalk.pub #安装证书 acme.sh --install-cert -d *.demo.dingtalk.pub --key-file /etc/nginx/ssl/demo.dingtalk.pub.key --fullchain-file /etc/nginx/ssl/demofullchain.cer --reloadcmd "systemctl restart nginx " #至此证书就已经颁发，并且key和cer已经被程序放在/etc/nginx/ssl/目录下，并且定期自动更新 #acme不会修改任何配置，ssl的相关配置，需要自己手动修改配置文件 #自动更新的脚本会被自动添加到定时器 [root@iZwz96589vyznjacr6y3ayZ ~]# crontab -l 58 0 * * * "/root/.</div></div></div><div class="relative w-100 w-30-l mb4 bg-white"><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>July 31, 2019</div><h1 class="f3 near-black"><a href=dingtalk.pub/post/1960106/ class="link black dim">mongodb用户权限管理</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">小小记录一下 mongo自己有很多的内置角色，权限的管理，可以按照k8s的理解来处理，即RBAC 。
内置角色可以直接使用，默认的角色有合理的权限划分，所以我们只要创建用户并且关联角色就可以了 角色具有namespace属性，在mongo中，不同数据库（类似namespace）的用户，即使是相同的用户，可以授予不同的角色；即用户和他关联的角色只有用户在特定的数据库下生效，并且，认证的时候也得选择特定的数据库来认证（区别于MySQL的，使用一个用户登录，不需要指定用来认证的数据库） 常规操作 #初始化副本集 use admin rs.initiate() #查看状态 rs.status() rs.isMaster() #添加副本集成员 rs.add('172.16.13.xx:27018') #删除节点 rs.remove('172.16.13.xx:27018') #查看副本集配置 rs.conf() #恢复步骤 首先恢复一个主节点，然后其他节点，再加入即可 #安全管理 https://docs.mongodb.com/manual/reference/built-in-roles/ #创建用户 use admin db.createUser( {user: "root",pwd: "root",roles: [ { role: "userAdminAnyDatabase", db: "admin" } ]}) #超级用户角色 db.createUser( {user: "cluster",pwd: "cluster",roles: [ { role: "clusterAdmin", db: "admin" } ]}) #集群管理员 db.createUser( {user: "test",pwd: "test",roles: [ { role: "readWrite", db: "test" } ]}) #数据库用户角色，一般用户使用 db.createUser( {user: "dbbackup",pwd: "dbbackup",roles: [ { role: "backup", db: "admin" } ]}) #系统内置备份角色 db.</div></div></div><div class="relative w-100 w-30-l mb4 bg-white"><div class="mb3 pa4 mid-gray overflow-hidden"><div class=f6>July 25, 2019</div><h1 class="f3 near-black"><a href=dingtalk.pub/post/2198278/ class="link black dim">nginx支持webp的图片智适应下发</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">背景 在同一个页面加载多张大图的时候，页面的载入速度，在我们的项目中，取决于图片的大小，页面总加载时间3s，图片加载时间将近1.5s。f12 查看分析，主要的耗时在图片加载，要怎么加快图片的加载呢，首先想到的就是图片的压缩 实践  在nginx中添加对图片的处理逻辑首先在HTTP这里添加：
http { include mime.types; default_type application/octet-stream; xxx... map $http_accept $webp_ext { default ""; "~*webp" ".webp"; } xxxx } 这里的意思是，判断HTTP的请求头是否包含webp，谷歌浏览器在请求图片时候的请求头如下如果包含，这里将设置一个变量webp_ext，它的值是**.webp**,这样，我们的请求的浏览器如果支持webp的图片格式，我们在server层的配置将尝试给浏览器返回一个webp格式的图片 在server层添加如下配置  location ~ .*\.(jpg|jpeg|gif|png)$ { add_header Vary Accept; try_files $uri$webp_ext $uri =404; root /usr/local/openresty/nginx/html; 这里，让我们所有请求图片的请求，使用try_files方法，首先尝试返回$uri$webp_ext所指向的图片，即如果原请求是xxx.png，则nginx这里尝试返回xxx.png.webp 。如果浏览器的请求头中没有webp这个关键字，那么这个变量的值就是原始的uri .即直接返回xxx.png 的原始图片，以适应不支持webp的浏览器 前提是，我们的网站目录中需要包含对应图片的webp格式，这个可以一次性生成，也可以配置nginx-lua在访问的时候实时生成。实时生成后面再研究，我这里在测试环境中，仅尝试一次性生成
yum install libwebp-tools cwebp -q 100 1.png -o 1.png.webp 下图为两个格式的加载时间对比 使用原始图像 使用压缩的webp图像</div></div></div></aside><ul class=pagination><li class=page-item><a href=dingtalk.pub/post/ class=page-link aria-label=First><span aria-hidden=true>&#171;&#171;</span></a></li><li class=page-item><a href=dingtalk.pub/post/page/4/ class=page-link aria-label=Previous><span aria-hidden=true>&#171;</span></a></li><li class=page-item><a class=page-link href=dingtalk.pub/post/>1</a></li><li class=page-item><a class=page-link href=dingtalk.pub/post/page/2/>2</a></li><li class=page-item><a class=page-link href=dingtalk.pub/post/page/3/>3</a></li><li class=page-item><a class=page-link href=dingtalk.pub/post/page/4/>4</a></li><li class="page-item active"><a class=page-link href=dingtalk.pub/post/page/5/>5</a></li><li class=page-item><a class=page-link href=dingtalk.pub/post/page/6/>6</a></li><li class="page-item disabled"><span aria-hidden=true>&nbsp;&mldr;&nbsp;</span></li><li class=page-item><a class=page-link href=dingtalk.pub/post/page/8/>8</a></li><li class=page-item><a href=dingtalk.pub/post/page/6/ class=page-link aria-label=Next><span aria-hidden=true>&#187;</span></a></li><li class=page-item><a href=dingtalk.pub/post/page/8/ class=page-link aria-label=Last><span aria-hidden=true>&#187;&#187;</span></a></li></ul></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=dingtalk.pub>&copy; snoopy 2021</a><div></div></div></footer></body></html>