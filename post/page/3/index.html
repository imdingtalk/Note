<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>My New Hugo Site</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="">
    <meta name="generator" content="Hugo 0.83.1" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    

  
  
    <link rel="stylesheet" href="/ananke/dist/main.css_5c99d70a7725bacd4c701e995b969fea.css" >
  




    
      

    

    
    
      <link href="/post/index.xml" rel="alternate" type="application/rss+xml" title="My New Hugo Site" />
      <link href="/post/index.xml" rel="feed" type="application/rss+xml" title="My New Hugo Site" />
      
    
    
    <meta property="og:title" content="Posts" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://example.org/post/" />

<meta itemprop="name" content="Posts">
<meta itemprop="description" content=""><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content=""/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    

  <header>
    <div class="pb3-m pb6-l bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        My New Hugo Site
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

      <div class="tc-l pv3 ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">
          Posts
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      

  <article class="pa3 pa4-ns nested-copy-line-height nested-img">
    <section class="cf ph3 ph5-l pv3 pv4-l f4 tc-l center measure-wide lh-copy mid-gray">
      
    </section>
    <aside class="flex-ns flex-wrap justify-around mt5">
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        June 6, 2020
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://example.org/post/7957457/" class="link black dim">
        win10 2004 使用wsl2
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      安装适用于 Linux 的 Windows 子系统  必须先启用“适用于 Linux 的 Windows 子系统”可选功能，然后才能在 Windows 上安装 Linux 分发版以管理员身份打开 PowerShell 并运行： dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 更新到 WSL 2 若要更新到 WSL 2，必须满足以下条件：
 运行 Windows 10（已更新到版本 2004 的内部版本 19041 或更高版本）。 通过按 Windows 徽标键 + R，检查你的 Windows 版本，然后键入 winver，选择“确定”。 （或者在 Windows 命令提示符下输入 ver 命令）。 确保内部版本不低于 19041   启用“虚拟机平台”可选组件 安装 WSL 2 之前，必须启用“虚拟机平台”可选功能。 以管理员身份打开 PowerShell 并运行： dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 重新启动计算机，以完成 WSL 安装并更新到 WSL 2。 更新 WSL 2 Linux 内核 下载 Linux 内核更新包,下载适用于 x64 计算机的最新 WSL2 Linux 内核更新包 将 WSL 2 设置为默认版本 安装新的 Linux 分发版时，请在 Powershell 中运行以下命令，以将 WSL 2 设置为默认版本： wsl --set-default-version 2 将分发版版本设置为 WSL 1 或 WSL 2 查看当前的Linux使用的wsl版本 wsl --list --verbose 若要将分发版设置为受某一 WSL 版本支持，运行：
    </div>
  </div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        May 8, 2020
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://example.org/post/6797397/" class="link black dim">
        记一次tls某些客户端访问极慢的问题
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      问题 公司使用的let&rsquo;s encrypt的通配证书用于公司的网站全站https化，最近反馈以下问题：
 win系统访问  
    </div>
  </div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        May 7, 2020
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://example.org/post/4986808/" class="link black dim">
        pvc扩容实践
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      准备工作 参考：https://kubernetes.io/docs/concepts/storage/persistent-volumes/#expanding-persistent-volumes-claims 前提  需要一个ceph集群 需要开启sc的allowVolumeExpansion   从k8s v1.11 版本开始支持
kind: StorageClass apiVersion: storage.k8s.io/v1 metadata: name: rbd provisioner: ceph.com/rbd parameters: monitors: 172.16.13.44:6789 pool: kube adminId: admin adminSecretNamespace: kube-system adminSecretName: ceph-admin-secret userId: kube userSecretNamespace: kube-system userSecretName: ceph-secret imageFormat: &#34;2&#34; imageFeatures: layering allowVolumeExpansion: true 制作镜像  制作 kube-controller-manager 镜像，增加rbd命令 from centos:7  COPY kube-controller-manager /usr/bin/kube-controller-manager RUN mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup COPY Centos-7.repo /etc/yum.repos.d/Centos-7.repo COPY epel-7.repo /etc/yum.repos.d/epel-7.repo COPY ceph.repo /etc/yum.repos.d/ceph.repo COPY ceph.client.admin.keyring /etc/ceph/ceph.client.admin.keyring COPY ceph.
    </div>
  </div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        May 7, 2020
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://example.org/post/6368447/" class="link black dim">
        Mysql 8
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      初始化 更新密码 #查找默认密码  systemctl status mysqld.service -l 或者 grep &#39;temporary password&#39; /var/log/mysqld.log #登录 mysql -uroot -p #修改默认密码 mysql&gt; ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;*{your-password}*&#39;; #创建用户 create user &#39;news&#39;@&#39;39.15.16.14&#39; identified by &#39;123news&#39;; #授权 grant all privileges on news.* to &#39;news&#39;@&#39;39.15.16.14&#39;; flush privileges; 忘记密码 # 参考 https://dev.mysql.com/doc/refman/8.0/en/resetting-permissions.html 
    </div>
  </div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        May 6, 2020
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://example.org/post/2525675/" class="link black dim">
        https的通信过程,TLS1.2
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      HTTPS简介 HTTPS其实是有两部分组成：HTTP + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据 过程解析 简单来说，是这样的：浏览器发起请求-&gt;服务端返回证书-&gt;浏览器使用证书（其中包含服务端的公钥）加密一段信息（pre master key + 握手信息）发给服务器-&gt;服务器使用私钥和计算出的对称密钥解密-&gt;服务器使用对称密码体系发送信息给浏览器。握手完成。实际上，其中还有一些复杂的东东：以上就是SSL的四次通信-&gt; 客户端向服务端发送请求，包含一个随机数C,稍后用于生成&quot;对话密钥&quot;。
 支持的协议版本，比如TLS 1.1版 一个客户端生成的随机数，稍后用于生成&quot;对话密钥&quot;。 支持的加密方法（用于加密随后的pre master key 和生成对称密钥?），比如RSA公钥加密。 支持的压缩算法等  -&gt; 服务端返回数字证书和选定的加密算法和hash算法以及一个随机数S,稍后用于生成&quot;对话密钥&quot;。
 确认使用的加密通信协议版本，比如TLS 1.1版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。 一个服务器生成的随机数，稍后用于生成&quot;对话密钥&quot;。 确认使用的加密方法，比如RSA公钥加密；以及服务器的证书  -&gt; 客户端用自己的CA[主流的CA机构证书一般都内置在各个主流浏览器中]公钥去解密证书,如果证书有问题会提示风险， 如果证书没问题客户端会生成一个随机数（pre-master key）结合随机数S和随机数C来计算出一个对称加密的密钥（enc_key=Fuc(random_C, random_S, Pre-Master）,pre-master key 将使用服务器的公钥加密；结合之前所有发送的信息和相关信息计算一个hash和一些其他信息，使用对称加密加密数据(不会发送密钥)，发给服务端；并发送编码改变通知
 一个随机数。该随机数用服务器公钥加密，防止被窃听。 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送  客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。  -&gt; 服务器收到加密信息后，使用私钥解密（可以验证服务器端有正确的私钥）出pre-master key ， 然后结合随机数S和随机数C来计算出一个对称加密的密钥，使用这个密钥解密对称加密后的信息，其中包含hash值；同时服务器端会计算之前所有收到的信息和相关信息的hash值。这两个值做对比，以确保双方可以使用协商好的对称密钥和算法加解密信息（同时也再次确认了服务器端有正确私钥）。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。并发送编码改变通知-&gt; 客户端解密接收后的信息，验证加密信息中的hash值和自己使用前面接收到的信息计算的hash值做对比，一致则验证通过，之后双方就拿着这个对称加密秘钥来进行正常的通信RSA密钥交换 称其为RSA密钥交换实际上是不准确的。 好吧，RSA使用非对称加密来创建会话密钥。公钥/私钥对扮演着重要角色。它在过程中：
 客户端和服务器交换两个素数（x和y），称为随机数。 客户端生成一个主密码（a），然后使用服务器的公钥对其进行加密并将其发送给服务器。 服务器使用相应的私钥解密预主密钥，双方现在都具有所有三个输入，并将它们与某些伪随机函数（PRF）混合以生成主密钥。 双方将更多的PRF与主密钥混合在一起，并得出匹配的会话密钥。  但是在实际应用中，已经很少使用RSA作为密钥交换算法 TLS 1.2 握手过程 – Diffie-Hellman 密钥交换  与RSA一样，客户端以“ ClientHello”消息开头，该消息包括密码套件列表以及客户端随机数。 服务器以自己的“ ServerHello”消息作为响应，该消息包括其选定的密码套件和服务器随机数。 服务器发送其SSL证书，就像使用RSA TLS握手一样，客户端将运行一系列检查以验证证书是否有效，但是由于DH本身无法验证服务器，因此需要其他机制。 为了提供身份验证，服务器将获取客户机和服务器的随机数以及将用于计算会话密钥的DH参数，并使用其私钥对其进行加密。此功能用作数字签名，客户端将使用公钥来验证签名-并且服务器是密钥对的合法所有者-并使用其自己的DH参数进行响应。 服务器以“Server Hello Done”消息结束此往返。 与RSA不同，客户端不需要使用非对称加密将主密码前的机密发送到服务器，而是客户端和服务器使用之前交换的DH参数来获取pre-master secret。然后，每个用户都使用它刚刚计算出的 pre-master secret来计算会话密钥。 客户端发送“Change Cipher Spec”消息，以通知另一方其已切换到加密。 客户端发送最后一条“Finished”消息，以表明它已完成握手的一部分。 同样，服务器发送“Change Cipher Spec”消息。 握手以服务器“Finished”消息结束。   参考 https://www.
    </div>
  </div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        May 5, 2020
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://example.org/post/6653199/" class="link black dim">
        Nginx TLS1.3 实践
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      TLS1.3 优势  在性能方面，TLS 1.2需要两次往返来建立HTTPS连接。使用TLS 1.3，仅需要一次往返。TLS 1.3还支持零往返模式  在安全性方面，TLS 1.3删除了对旧密码套件的支持   在Nginx中启用TLS 1.3  要使用Nginx启用TLS 1.3，有两个要求。
 Nginx版本必须支持TLS 1.3。这需要nginx 1.13或更高。 Nginx需要使用OpenSSL 1.1.1+构建或与OpenSSL 1.1.1+一起运行。   这里直接使用三方源来安装 yum install &#34;https://packages.exove.com/yum/el7/exove-centos-release.el7.noarch.rpm&#34; yum update nginx [root@biao ~]# nginx -V nginx version: nginx/1.18.0 (packages.exove.com: SSE2, openssl-1.1.1g, PCRE JIT, TCP Fast Open) built by gcc 8.3.1 20190311 (Red Hat 8.3.1-3) (GCC) built with OpenSSL 1.1.1g 21 Apr 2020 TLS SNI support enabled 开启配置 server { listen 443 ssl; root /opt/www/tls; ssl_certificate /opt/www/tls/server.
    </div>
  </div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        May 5, 2020
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://example.org/post/6653455/" class="link black dim">
        TLS1.3 初识，握手过程和优化
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      更快，更安全  TLS1.3的最终版本已于2018.8月发布（RFC8446）对于TLS 1.2，需要两次往返来完成TLS握手。在1.3版本中，它仅需要一次往返，_ _从而将加密延迟减少了一半。这有助于使这些加密的连接比以前更灵活 TLS 1.3浏览器支持  从Chrome 65 开始，Chrome在beta支持，在Chrome 70（于2018年10月发布）中，TLS 1.3的最终版本已启用，用于发出连接请求（即首次请求会申明我支持TLS1.3）。 在Firefox 52及更高版本（包括Quantum）中启用了TLS 1.3的beta版本。 Firefox 63（于2018年10月发布）的,支持最终版本为TLS 1.3。 Microsoft Edge开始开始在76版本支持TLS 1.3，并且默认情况下在macOS 10.14.4的Safari 12.1中启用了该功能。   相对于TLS1.2的变化   消除了对过时的算法和密码的支持 消除RSA密钥交换，要求完善的前向保密性 减少握手中的协商次数 将密码套件中的算法数量减少到2 消除了块模式密码并强制执行AEAD批量加密 使用HKDF密码提取和密钥派生 提供1-RTT模式和零往返恢复 签名整个握手协议，对TLS 1.2进行了改进 支持其他椭圆曲线   消除了易受攻击的算法和密码 时间一直都是并且永远都是任何加密系统的敌人，随着时间的流逝，发现特定加密系统的漏洞和对漏洞的利用，会给加密系统带来很大的风险，前向保密性保证了长期使用的主密钥泄漏不会导致过去的会话密钥泄漏，可以保证在主密钥泄露时历史通讯的安全，即使系统遭到主动攻击也是如此 简化密钥交换过程  一般来说，有两种流行的机制用于交换握手后将在HTTPS连接期间使用的安全会话密钥：
 RSA Diffie-Hellman  新版在密钥交换期间已经完全弃用了RSA，实际上上在1.2版本中也很少使用RSA 这是OpenSSL现在支持的五个TLS 1.3密码套件。
 TLS_AES_256_GCM_SHA384 TLS_CHACHA20_POLY1305_SHA256 TLS_AES_128_GCM_SHA256 TLS_AES_128_CCM_8_SHA256 TLS_AES_128_CCM_SHA256   密码协商过程  TLS1.2 套件示例TLS 1.3对其前身进行了无数的改进，IETF取消了对较旧的过时算法的支持，并简化了所有流程，将整个握手过程从两次往返缩短为一次，并将密码套件的大小从四个协商/算法减少为两个(密钥交换算法始终未DHE或者ECDHE;)。支持的密码套件的数量也从37个减少到5个。这是TLS 1.3密码套件的示例：在hello时我们将知道使用某种版本的Diffie-Hellman临时密钥交换（密钥交换不需要协商了），我们只是不知道参数，因此这意味着不再需要TLS 1.2密码套件中的前两个算法（对称加密和认证算法）。这些功能仍在发生，而不再需要在握手期间进行协商，TLS 1.3允许的唯一对称密码类型称为带有附加数据的身份验证加密（AEAD）密码。 常见的 AEAD 算法如下：
    </div>
  </div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        April 23, 2020
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://example.org/post/5953671/" class="link black dim">
        k8s使用glusterFS做SC存储
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      准备 前提是需要准备好一个gluster集群，并提供rest url 应用 创建一个storageclass apiVersion: storage.k8s.io/v1 kind: StorageClass metadata: name: gluster-vol-default provisioner: kubernetes.io/glusterfs parameters: resturl: &#34;http://192.168.10.100:8080&#34; restuser: &#34;&#34; secretNamespace: &#34;&#34; secretName: &#34;&#34; volumetype: &#34;replicate:3&#34; #允许卷扩展，PVC可以在使用的时候调整大小 #https://kubernetes.io/docs/concepts/storage/persistent-volumes/#expanding-persistent-volumes-claims allowVolumeExpansion: true --- apiVersion: v1 kind: Secret metadata: name: heketi-secret namespace: default data: # base64 encoded password. E.g.: echo -n &#34;mypassword&#34; | base64 key: bXlwYXNzd29yZA== type: kubernetes.io/glusterfs secret示例文件参考： https://kubernetes.io/docs/concepts/storage/storage-classes/#glusterfs https://github.com/kubernetes/examples/blob/master/staging/persistent-volume-provisioning/glusterfs/glusterfs-storageclass.yaml
    </div>
  </div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        April 22, 2020
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://example.org/post/6033915/" class="link black dim">
        quay,gcr镜像国内拉取
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      常用镜像仓库 DockerHub镜像仓库:https://hub.docker.com/阿里云镜像仓库：https://cr.console.aliyun.comgoogle镜像仓库：http://gcr.io/google-containers/http://gcr.io/kubernetes-helm/coreos镜像仓库：https://quay.io/repository/RedHat镜像仓库：https://access.redhat.com/containers docker.io 镜像加速  针对Docker客户端版本大于 1.10.0 的用户可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39; { &#34;registry-mirrors&#34;: [&#34;https://d0rzu7aw.mirror.aliyuncs.com&#34;] } EOF sudo systemctl daemon-reload sudo systemctl restart docker 或者使用中科大的镜像 docker pull docker.mirrors.ustc.edu.cn/library/mysql:5.7 gcr.io镜像  推荐使用阿里云的镜像 #示例 docker pull k8s.gcr.io/pause:3.2 #改为 docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.2 docker pull registry.aliyuncs.com/google_containers/kube-proxy:v1.18.0 微软云的镜像本来很给力，但是后面不开放给公共使用了 说明参考这个链接： http://mirror.azure.cn/help/gcr-proxy-cache.html quay.io镜像加速  #示例 docker pull quay.io/xxx/yyy:zzz #改为 docker pull quay.mirrors.ustc.edu.cn/xxx/yyy:zzz 以拉取quay.io/coreos/kube-state-metrics:v1.5.0为例，如下： docker pull quay.mirrors.ustc.edu.cn/coreos/kube-state-metrics:v1.5.0 使用代理 要是所有的仓库都不给力的话，那就使用自己的代理咯 vim /etc/systemd/system/docker.service.d/docker-proxy.conf [Service] Environment=&#34;HTTP_PROXY=http://172.16.8.244:10809/&#34; &#34;HTTPS_PROXY=http://172.16.8.244:10809/&#34; &#34;NO_PROXY=localhost,127.
    </div>
  </div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        April 21, 2020
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://example.org/post/6306716/" class="link black dim">
        k8s零宕机滚动更新
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      滚动更新 默认情况下，Kubernetes 的 Deployment 是具有滚动更新的策略来进行 Pod 更新的，该策略可以在任何时间点更新应用的时候保证某些实例依然可以正常运行来防止应用 down 掉，当新部署的 Pod 启动并可以处理流量之后，才会去杀掉旧的 Pod。下面示例是使用默认的滚动更新升级策略的一个 Deployment 定义，在更新过程中最多可以有一个超过副本数的容器（maxSurge），并且在更新过程中没有不可用的容器。 apiVersion: apps/v1 kind: Deployment metadata: labels: app: testready name: testready spec: replicas: 2 selector: matchLabels: app: testready template: metadata: labels: app: testready spec: containers: - image: nginx:1.12 name: nginx readinessProbe: exec: command: - grep - &#34;jvm&#34; - /tmp/healthy initialDelaySeconds: 5 periodSeconds: 5 --- apiVersion: v1 kind: Service metadata: labels: app: testready name: testready spec: ports: - name: &#34;80&#34; port: 80 protocol: TCP targetPort: 80 selector: app: testready type: NodePort 观察pod的就绪状态及服务ep状态
    </div>
  </div>

        </div>
      
    </aside>
    
<ul class="pagination">
  <li class="page-item">
    <a href="/post/" class="page-link" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
  </li>
  <li class="page-item">
    <a href="/post/page/2/" class="page-link" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
  </li>
  <li class="page-item">
    <a class="page-link" href="/post/">1</a>
  </li>
  <li class="page-item">
    <a class="page-link" href="/post/page/2/">2</a>
  </li>
  <li class="page-item active">
    <a class="page-link" href="/post/page/3/">3</a>
  </li>
  <li class="page-item">
    <a class="page-link" href="/post/page/4/">4</a>
  </li>
  <li class="page-item disabled">
    <span aria-hidden="true">&nbsp;&hellip;&nbsp;</span>
  </li>
  <li class="page-item">
    <a class="page-link" href="/post/page/8/">8</a>
  </li>
  <li class="page-item">
    <a href="/post/page/4/" class="page-link" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
  </li>
  <li class="page-item">
    <a href="/post/page/8/" class="page-link" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
  </li>
</ul>


  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://example.org/" >
    &copy;  My New Hugo Site 2021 
  </a>
    <div>














</div>
  </div>
</footer>

  </body>
</html>
