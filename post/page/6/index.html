<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>My New Hugo Site</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="">
    <meta name="generator" content="Hugo 0.83.1" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    

  
  
    <link rel="stylesheet" href="/ananke/dist/main.css_5c99d70a7725bacd4c701e995b969fea.css" >
  




    
      

    

    
    
      <link href="/post/index.xml" rel="alternate" type="application/rss+xml" title="My New Hugo Site" />
      <link href="/post/index.xml" rel="feed" type="application/rss+xml" title="My New Hugo Site" />
      
    
    
    <meta property="og:title" content="Posts" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://example.org/post/" />

<meta itemprop="name" content="Posts">
<meta itemprop="description" content=""><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content=""/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    

  <header>
    <div class="pb3-m pb6-l bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        My New Hugo Site
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

      <div class="tc-l pv3 ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">
          Posts
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      

  <article class="pa3 pa4-ns nested-copy-line-height nested-img">
    <section class="cf ph3 ph5-l pv3 pv4-l f4 tc-l center measure-wide lh-copy mid-gray">
      
    </section>
    <aside class="flex-ns flex-wrap justify-around mt5">
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        June 23, 2019
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://example.org/post/1960034/" class="link black dim">
        mongodb副本集搭建
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      介绍 副本集是mongoDB副本所组成的一个集群，集群中没有特定的主库，主库是选举产生，如果主库down了，会再选举出一台主库
正常状态下拓扑故障切换过程
副本集有以下特点：1. 最小构成是：primary，secondary，arbiter，一般部署是：primary，2 secondary。2. 成员数应该为奇数，如果为偶数的情况下添加arbiter，arbiter不保存数据，只投票。3. 最大50 members，但是只能有 7 voting members，其他是non-voting members。 部署 下载mongod：https://www.mongodb.com/download-center/community加入到系统路径：chmod +x mongod &amp;&amp; cp mongod /usr/bin/创建用户并设置密码： useradd mongod &amp;&amp; passwd mongod编辑配置文件 # mongod.conf # for documentation of all options, see: # http://docs.mongodb.org/manual/reference/configuration-options/ # where to write logging data. systemLog: destination: file logAppend: true path: /var/log/mongodb/mongod1.log # Where and how to store data. storage: dbPath: /var/lib/mongo1 journal: enabled: true # engine: # mmapv1: # wiredTiger: # how the process runs processManagement: fork: true # fork and run in background pidFilePath: /var/run/mongodb/mongod1.
    </div>
  </div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        June 23, 2019
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://example.org/post/1959886/" class="link black dim">
        mongodb使用pymongo批量插入数据
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      背景 在测试mongo相关功能的时候，需要批量插入数据，写一个脚本来批量插入 环境准备 安装 pymongo ，直接使用pip3安装，后面使用insert_many,insert_one的时候会报错如下，是因为默认安装的版本不是最新的，旧版本不支持最新的函数，直接安装最新的，pip3 install -U pymongo但是使用系统默认的python3，运行，会遇到各种问题，因为centos7系统默认的python3的path和pip3安装的东西不匹配，所以这里我直接用/usr/local/python3.6.4/bin,下的执行文件，而不是系统默认的/usr/bin/python3
TypeError: &#39;Collection&#39; object is not callable. If you meant to call the &#39;insert_one&#39; method on a &#39;Collection&#39; object it is failing because no such method exists. 插入数据 import pymongo from pymongo import MongoClient #处理连接信息。建立连接 auth_str=&#39;cluster:cluster@&#39; host_info=&#39;172.16.13.44:27017,172.16.13.44:27018,172.16.13.44:27019&#39; MONGODB=&#39;test&#39; param_str=&#39;?authMechanism=SCRAM-SHA-1&amp;authSource=admin&amp;replicaSet=rs0&#39; uri=&#39;mongodb://%s%s/%s%s&#39; % (auth_str, host_info, MONGODB, param_str) #print(uri) client = MongoClient(uri) #选项数据库插入数据 db=client.test db.test.count() list(db.test.find()) result = db.test.insert_many([{&#39;x&#39;: i} for i in range(1000000)]) result.inserted_ids db.
    </div>
  </div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        June 19, 2019
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://example.org/post/1940892/" class="link black dim">
        处理api中关于operators.coreos.com的报错
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      背景  在测试环境中的监控一直报错，kubeapierrorhigh,经查看，是default，ns中存在异常的api，通过kubectl api-resources 发现该进程，已无法提供访问处理 删除对应的出问题的api
kubectl delete -n kube-system delete apiservice v1.packages.operators.coreos.com 删除对应的 api后，对应的告警没有了，至于具体这个出错的原因，始终没弄清楚，但是这个api不影响集群，所以先删除了
    </div>
  </div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        June 6, 2019
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://example.org/post/1165522/" class="link black dim">
        使用kubeadm创建一个高可用的集群
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      准备环境 需要事先准备好haproxy环境和keepalived环境以及容器运行时（参考这里），同时满足以下最小配置的需求至少2G的内存和至少2核的CPU，关闭swap，kubelet必须在swap关闭的情况下才能启动关闭指令：
swapoff -a 开始部署 k8s组件准备 首先安装kubeadm kubelet kubectl ，我们这里使用阿里云的源来安装，所有的节点都需要这个：
cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo [kubernetes] name=Kubernetes baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/ enabled=1 gpgcheck=1 repo_gpgcheck=1 gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg EOF setenforce 0 yum install -y kubelet kubeadm kubectl systemctl enable kubelet &amp;&amp; systemctl start kubelet 镜像准备 kubeadm的安装方式，把k8s的主要组件，kube-apiserver,kube-controller-manager,kube-proxy,kube-scheduler,coredns,etcd,pause这些组建的都通过镜像使用静态pod的方式启动。首先我们这里要准备好镜像，以便在初始化的时候，加快部署方式，同时排坑。如果你的环境可以访问谷歌那么可以直接通过命令下载：
# 如果你的环境可以访问Google，那么可以通过以下命令下载好所有的镜像 kubeadm config images pull # 如果以上命令执行失败，那么可以使用我准备dockerhub上的源来获取 cat pull_from_docker_hub.sh #!/bin/bash KUBE_VERSION=v1.13.2 KUBE_PAUSE_VERSION=3.1 ETCD_VERSION=3.2.24 COREDNS_VERSION=1.2.6 GCR_URL=k8s.gcr.io HUB=imdingtalk images=(kube-proxy:${KUBE_VERSION} kube-scheduler:${KUBE_VERSION} kube-controller-manager:${KUBE_VERSION} kube-apiserver:${KUBE_VERSION} kube-proxy:${KUBE_VERSION} pause:${KUBE_PAUSE_VERSION} etcd:${ETCD_VERSION} coredns:${COREDNS_VERSION} ) for imageName in ${images[@]} ; do docker pull $HUB/$imageName docker tag $HUB/$imageName $GCR_URL/$imageName docker rmi $HUB/$imageName done docker images # 以上，即可直接从docker hub获取镜像，并重新打tag为k8s.
    </div>
  </div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        May 24, 2019
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://example.org/post/1768801/" class="link black dim">
        mongodb副本集重新配置
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      背景 最开始部署mongodb副本集的时候使用的是本地地址，导致后面使用连接工具无法远程连接，故需要修改初始化的副本集配置 配置  &gt; db.version(); 4.0.9 &gt; conf=rs.conf() &gt; conf.members[0].host=&#34;172.16.13.x:27017&#34;; &gt; conf.members[1].host=&#34;172.16.13.x:27018&#34;; &gt; conf.members[2].host=&#34;172.16.13.x:27019&#34;; &gt; rs.reconfig(conf,{&#34;force&#34;:true}); 
    </div>
  </div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        May 16, 2019
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://example.org/post/1499735/" class="link black dim">
        MYSQL高可用架构之MHA实践
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      简介 MHA（Master High Availability）目前在MySQL高可用方面是一个相对成熟的解决方案 经典架构 说明：1.MHA-manager可以安装在除MYSQL-Master以外的任意服务器，唯一的要求是能和所有的DB服务器进行SSH通信2.在所有的MYSQL服务器上安装MHA-node
工作流程 安装部署 keepalive配置 keep主要提供故障切换时候的VIP漂移 #安装 yum install keepalived -y 配置 global_defs { smtp_server 192.168.200.1 smtp_connect_timeout 30 router_id LVS_MASTER } vrrp_instance VI_110 { interface ens33 virtual_router_id 110 nopreempt priority 110 advert_int 1 authentication { auth_type PASS auth_pass keepalived } virtual_ipaddress { 192.168.206.144 } } 根据 priority 字段自动判别主备，所以这个配置，在三台服务器之间应该不一致 数据库主从配置 配合5.6数据库新特性，配置主从变得异常简单，需要开启GTID，需要启用这三个参数，所有数据库添加该配置，先主库后从库，添加配置后，需要重启MySQL服务
vim /usr/local/mysql/my.cnf #GTID  gtid_mode = on enforce_gtid_consistency = 1 log_slave_updates = 1 创建主从复制的用户，并在从库配置认主 #创建主从复制用户 grant replication slave on *.
    </div>
  </div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        May 16, 2019
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://example.org/post/1697464/" class="link black dim">
        kubeadm安装的集群的备份和恢复实践
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      说明 本文档简述了Kubernetes主节点灾备恢复的相关步骤，供在发生k8s master崩溃时操作 **环境：**kubeadm安装的k8s 1.14.1 实践 查看集群的成员和现存的key
ETCDCTL_API=3 etcdctl --cacert=/etc/kubernetes/pki/etcd/ca.crt \ --cert=/etc/kubernetes/pki/etcd/peer.crt \ --key=/etc/kubernetes/pki/etcd/peer.key \ member list ETCDCTL_API=3 etcdctl --cacert=/etc/kubernetes/pki/etcd/ca.crt \ --cert=/etc/kubernetes/pki/etcd/peer.crt \ --key=/etc/kubernetes/pki/etcd/peer.key \ get / --prefix --keys-only 备份的实现和恢复 etcd集群数据备份，这里我写了一个脚本实现
#!/bin/bash #脚本需要依赖etcdctl，安装 yum install etcd #获取脚本所存放目录 cd `dirname $0` bash_path=`pwd` #脚本名 me=$(basename $0) # delete dir and keep days delete_dirs=(&#34;/data/backup/kubernetes:7&#34;) backup_dir=/data/backup/kubernetes files_dir=(&#34;/etc/kubernetes&#34; &#34;/var/lib/kubelet&#34;) log_dir=$backup_dir/log shell_log=$log_dir/${USER}_${me}.log ssh_port=&#34;22&#34; ssh_parameters=&#34;-o StrictHostKeyChecking=no -o ConnectTimeout=60&#34; ssh_command=&#34;ssh ${ssh_parameters}-p ${ssh_port}&#34; scp_command=&#34;scp ${ssh_parameters}-P ${ssh_port}&#34; DATE=$(date +%F) TIME=$(date &#39;+%Y%m%d%H&#39;) BACK_SERVER=&#34;127.
    </div>
  </div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        May 13, 2019
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://example.org/post/1676198/" class="link black dim">
        通过域控下发软件安装过程
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      背景 出于安全考虑，在域中的服务器需要批量安装某软件。 实施 脚本如下 do Set Of = CreateObject(&#34;Scripting.FileSystemObject&#34;) Set objShell = CreateObject(&#34;Shell.Application&#34;) dim OK,oShell OK=False set bag=getobject(&#34;winmgmts:\\.\root\cimv2&#34;) set pipe=bag.execquery(&#34;select * from win32_process where name=&#39;xxx.exe&#39;&#34;) for each match in pipe OK = True msgbox &#34;xxx.exe正在运行。。。&#34; WScript.Quit Next If not OK Then msgbox &#34;xxx.exe没有运行！&#34; Set objShell = CreateObject(&#34;Wscript.Shell&#34;) WScript.Sleep 1000 msgbox &#34;请手动完成xx客户端的安装，否则每次开机都提示&#34;,0 strCommandLine = &#34;\\chinawyny.com\SysVol\domain.com\Policies\{5A850BAF-1901-4071-AD41-1AF69B9BEAA8}\User\Scripts\Logon\DSMClientSetup.exe&#34; objShell.Run(strCommandLine) set WshShell = CreateObject(&#34;WScript.Shell&#34;) WScript.Sleep 1000 msgbox &#34;要显示的内容&#34;,0 WScript.Quit end if loop 这里首先检测目标主机上是否安装了对应的程序并且已经自启动，如果已经启动，则提示软件已经在运行，如果没有运行则提示需要安装，如果是静默安装包，还可以实现静默安装，不弹出setup的安装步骤。软件的安装文件 路径为，域控服务器上的指定地址。 然后编辑域控的策略，添加该脚本即可 
    </div>
  </div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        April 30, 2019
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://example.org/post/1144573/" class="link black dim">
        k8s 使用kubeconfig和token访问集群
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      概述 kubectl命令访问集群时，默认情况下在$HOME/.kube目录下寻找名为config的配置文件，配置文件中包含集群API地址、端口号、证书等，kubectl据此建构访问集群的上下文。 场景 实际我们在使用中开发需要特定namespace的权限，并且不能有集群的远程权限，使用API访问集群，运维拥有集群的所有控制权，仅有一个集群，于是使用RBAC做权限控制。 制作kubeconfig，同时支持kubectl远程访问和通过token访问API。 环境准备 curl -s -L -o /bin/cfssl https://pkg.cfssl.org/R1.2/cfssl_linux-amd64 curl -s -L -o /bin/cfssljson https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64 curl -s -L -o /bin/cfssl-certinfo https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64 chmod +x /bin/cfssl* 准备好证书请求文件
  cat&gt; user-csr.json &laquo;EOF { &ldquo;CN&rdquo;: &ldquo;USER&rdquo;, &ldquo;hosts&rdquo;: [], &ldquo;key&rdquo;: { &ldquo;algo&rdquo;: &ldquo;rsa&rdquo;, &ldquo;size&rdquo;: 2048 }, &ldquo;names&rdquo;: [ { &ldquo;C&rdquo;: &ldquo;CN&rdquo;, &ldquo;ST&rdquo;: &ldquo;BeiJing&rdquo;, &ldquo;L&rdquo;: &ldquo;BeiJing&rdquo;, &ldquo;O&rdquo;: &ldquo;k8s&rdquo;, &ldquo;OU&rdquo;: &ldquo;System&rdquo; } ] } EOF
&gt; &lt;a name=&quot;63199eed&quot;&gt;&lt;/a&gt; ### 定义集群、用户、上下文 制作kubeconf主要有三步： 1. 为配置文件添加集群信息 1.
    </div>
  </div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          
            <div class="mb3 pa4 mid-gray overflow-hidden">
    
      <div class="f6">
        April 28, 2019
      </div>
    
    <h1 class="f3 near-black">
      <a href="http://example.org/post/1583929/" class="link black dim">
        K8S的污点（Taints ）和容忍（Tolerations）
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      节点亲和性是pod的一个属性，它将它们_吸引_到一组节点（作为首选项或硬性要求），Taints 是与之相反的，它允许节点驱逐或抵制一个pod 污点和容忍一起工作以确保不将pod安排到不适当的节点上。 将一个或多个污点应用于节点; 这标志着节点不应该接受任何不能容忍污点的pod。 容忍应用于容器，并允许（但不要求）容器安排到具有匹配的污点的节点上。 概念 使用kubectl taints为节点添加污点。例如 kubectl taint nodes node1 key=value:NoSchedule 在节点node1上放置污点。污点具有键key，值value和污点效果 NoSchedule。这意味着没有pod将能够调度到node1上，除非与pod具有匹配的容忍度。要删除上面命令添加的污点，您可以运行： kubectl taint nodes node1 key:NoSchedule- 在PodSpec中指定容器的容忍Tolerations。以下两种容忍度都“匹配”上面的kubectl污染线所产生的污点，因此具有任何容忍度的容器将能够安排到node1上：
tolerations: - key: &#34;key&#34; operator: &#34;Equal&#34; value: &#34;value&#34; effect: &#34;NoSchedule&#34; tolerations: - key: &#34;key&#34; operator: &#34;Exists&#34; effect: &#34;NoSchedule&#34; 如果key是相同的并且effect相同，则容忍和污点匹配，并且：  operator是Exists（在这种情况下不应指定key），或  operator是Equal，值相等   如果未指定，则operator默认为Equal。 **两种特殊情况： **
 带有operator Exists的空键匹配所有key，value和effect，这意味着它将容忍所有内容。   tolerations: - operator: &#34;Exists&#34;  空effect使用key:key匹配所有effect。   tolerations: - key: &#34;key&#34; operator: &#34;Exists&#34; 上面的例子使用了NoSchedule的effect。或者，您可以使用PreferNoSchedule的效果。这是NoSchedule的“首选”或“软”版本 - 系统将尽量避免放置不能容忍节点上污点的pod，但这不是必需的。第三种效果是NoExecute，稍后描述。 您可以在同一节点上放置多个污点，并在同一个pod上放置多个容差。Kubernetes处理多个污点和容忍的方式就像一个过滤器：从所有节点的污点开始，然后忽略pod具有匹配容忍度的那些;剩下的未被忽视的污点对吊舱有明显的影响。特别是  如果至少有一个未被忽略的污点具有效果NoSchedule，那么Kubernetes将不会将pod安排到该节点上  如果没有未被忽略的污点，效果NoSchedule，但至少有一个未被忽略的污点有效PreferNoSchedule然后Kubernetes将尝试不将pod安排到节点  如果存在至少一个具有effect** ** **NoExecute**的未被忽略的污点，则该pod将从该节点逐出（如果它已经在该节点上运行），并且将不会被调度到该节点上（如果它尚未在该节点上运行）。   例如，假设您的节点有这样的污点： kubectl taint nodes node1 key1=value1:NoSchedule kubectl taint nodes node1 key1=value1:NoExecute kubectl taint nodes node1 key2=value2:NoSchedule pod有两种容忍度： tolerations: - key: &#34;key1&#34; operator: &#34;Equal&#34; value: &#34;value1&#34; effect: &#34;NoSchedule&#34; - key: &#34;key1&#34; operator: &#34;Equal&#34; value: &#34;value1&#34; effect: &#34;NoExecute&#34; 在这种情况下，pod将无法安排到节点上，因为没有容忍匹配第三种污点。但是，如果在添加污点时pod已经在节点上运行，它将能够继续运行，因为第三种污点是容器中不能容忍的三种污染中唯一的一种。（pod可以容忍node1有污点 key1=value1:NoSchedule和key1=value1:NoExecute，但是不容忍key2=value2:NoSchedule，但是key2的effect为NoSchedule，意味着在添加污点的时候如果pod已经在该node运行，则不采取处理。如果没有在该node运行，将不会调度到该节点。如果污点 key2=value2:NoExecute，pod容忍不变，那么即使已经在该node运行，添加了该污点后，pod也会被驱逐） 通常情况下，如果将一个带有NoExecute效果的污点添加到一个节点，那么任何不能容忍污染的pod都会立即被驱逐，任何容忍污染的pod都不会被驱逐。但是，对NoExecute效果的容忍可以指定一个可选的tolerationSeconds字段，该字段指示在添加污点后pod将保持绑定到节点的时间。例如， tolerations: - key: &#34;key1&#34; operator: &#34;Equal&#34; value: &#34;value1&#34; effect: &#34;NoExecute&#34; tolerationSeconds: 3600 意味着如果此pod正在运行并且将匹配的污点添加到节点，则pod将保持绑定到该节点3600秒，然后被逐出。如果在此之前删除了污点，则不会驱逐pod。 另外一个pod会被默认添加一个Tolerations： 以上的Tolerations意味着：如果node的状态处于not_ready状态超过5分钟，那么该pod将不能在node上继续执行，将被驱逐。 附注： kubernetes节点失效后pod的调度过程 1.
    </div>
  </div>

        </div>
      
    </aside>
    
<ul class="pagination">
  <li class="page-item">
    <a href="/post/" class="page-link" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
  </li>
  <li class="page-item">
    <a href="/post/page/5/" class="page-link" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
  </li>
  <li class="page-item">
    <a class="page-link" href="/post/">1</a>
  </li>
  <li class="page-item">
    <a class="page-link" href="/post/page/2/">2</a>
  </li>
  <li class="page-item">
    <a class="page-link" href="/post/page/3/">3</a>
  </li>
  <li class="page-item disabled">
    <span aria-hidden="true">&nbsp;&hellip;&nbsp;</span>
  </li>
  <li class="page-item">
    <a class="page-link" href="/post/page/5/">5</a>
  </li>
  <li class="page-item active">
    <a class="page-link" href="/post/page/6/">6</a>
  </li>
  <li class="page-item">
    <a class="page-link" href="/post/page/7/">7</a>
  </li>
  <li class="page-item">
    <a class="page-link" href="/post/page/8/">8</a>
  </li>
  <li class="page-item">
    <a href="/post/page/7/" class="page-link" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
  </li>
  <li class="page-item">
    <a href="/post/page/8/" class="page-link" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
  </li>
</ul>


  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://example.org/" >
    &copy;  My New Hugo Site 2021 
  </a>
    <div>














</div>
  </div>
</footer>

  </body>
</html>
