<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>K8S的污点（Taints ）和容忍（Tolerations） | My New Hugo Site</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="节点亲和性是pod的一个属性，它将它们_吸引_到一组节点（作为首选项或硬性要求），Taints 是与之相反的，它允许节点驱逐或抵制一个pod 污点和容忍一起工作以确保不将pod安排到不适当的节点上。 将一个或多个污点应用于节点; 这标志着节点不应该接受任何不能容忍污点的pod。 容忍应用于容器，并允许（但不要求）容器安排到具有匹配的污点的节点上。 概念 使用kubectl taints为节点添加污点。例如 kubectl taint nodes node1 key=value:NoSchedule 在节点node1上放置污点。污点具有键key，值value和污点效果 NoSchedule。这意味着没有pod将能够调度到node1上，除非与pod具有匹配的容忍度。要删除上面命令添加的污点，您可以运行： kubectl taint nodes node1 key:NoSchedule- 在PodSpec中指定容器的容忍Tolerations。以下两种容忍度都“匹配”上面的kubectl污染线所产生的污点，因此具有任何容忍度的容器将能够安排到node1上：
tolerations: - key: &#34;key&#34; operator: &#34;Equal&#34; value: &#34;value&#34; effect: &#34;NoSchedule&#34; tolerations: - key: &#34;key&#34; operator: &#34;Exists&#34; effect: &#34;NoSchedule&#34; 如果key是相同的并且effect相同，则容忍和污点匹配，并且：  operator是Exists（在这种情况下不应指定key），或  operator是Equal，值相等   如果未指定，则operator默认为Equal。 **两种特殊情况： **
 带有operator Exists的空键匹配所有key，value和effect，这意味着它将容忍所有内容。   tolerations: - operator: &#34;Exists&#34;  空effect使用key:key匹配所有effect。   tolerations: - key: &#34;key&#34; operator: &#34;Exists&#34; 上面的例子使用了NoSchedule的effect。或者，您可以使用PreferNoSchedule的效果。这是NoSchedule的“首选”或“软”版本 - 系统将尽量避免放置不能容忍节点上污点的pod，但这不是必需的。第三种效果是NoExecute，稍后描述。 您可以在同一节点上放置多个污点，并在同一个pod上放置多个容差。Kubernetes处理多个污点和容忍的方式就像一个过滤器：从所有节点的污点开始，然后忽略pod具有匹配容忍度的那些;剩下的未被忽视的污点对吊舱有明显的影响。特别是  如果至少有一个未被忽略的污点具有效果NoSchedule，那么Kubernetes将不会将pod安排到该节点上  如果没有未被忽略的污点，效果NoSchedule，但至少有一个未被忽略的污点有效PreferNoSchedule然后Kubernetes将尝试不将pod安排到节点  如果存在至少一个具有effect** ** **NoExecute**的未被忽略的污点，则该pod将从该节点逐出（如果它已经在该节点上运行），并且将不会被调度到该节点上（如果它尚未在该节点上运行）。   例如，假设您的节点有这样的污点： kubectl taint nodes node1 key1=value1:NoSchedule kubectl taint nodes node1 key1=value1:NoExecute kubectl taint nodes node1 key2=value2:NoSchedule pod有两种容忍度： tolerations: - key: &#34;key1&#34; operator: &#34;Equal&#34; value: &#34;value1&#34; effect: &#34;NoSchedule&#34; - key: &#34;key1&#34; operator: &#34;Equal&#34; value: &#34;value1&#34; effect: &#34;NoExecute&#34; 在这种情况下，pod将无法安排到节点上，因为没有容忍匹配第三种污点。但是，如果在添加污点时pod已经在节点上运行，它将能够继续运行，因为第三种污点是容器中不能容忍的三种污染中唯一的一种。（pod可以容忍node1有污点 key1=value1:NoSchedule和key1=value1:NoExecute，但是不容忍key2=value2:NoSchedule，但是key2的effect为NoSchedule，意味着在添加污点的时候如果pod已经在该node运行，则不采取处理。如果没有在该node运行，将不会调度到该节点。如果污点 key2=value2:NoExecute，pod容忍不变，那么即使已经在该node运行，添加了该污点后，pod也会被驱逐） 通常情况下，如果将一个带有NoExecute效果的污点添加到一个节点，那么任何不能容忍污染的pod都会立即被驱逐，任何容忍污染的pod都不会被驱逐。但是，对NoExecute效果的容忍可以指定一个可选的tolerationSeconds字段，该字段指示在添加污点后pod将保持绑定到节点的时间。例如， tolerations: - key: &#34;key1&#34; operator: &#34;Equal&#34; value: &#34;value1&#34; effect: &#34;NoExecute&#34; tolerationSeconds: 3600 意味着如果此pod正在运行并且将匹配的污点添加到节点，则pod将保持绑定到该节点3600秒，然后被逐出。如果在此之前删除了污点，则不会驱逐pod。 另外一个pod会被默认添加一个Tolerations： 以上的Tolerations意味着：如果node的状态处于not_ready状态超过5分钟，那么该pod将不能在node上继续执行，将被驱逐。 附注： kubernetes节点失效后pod的调度过程 1.">
    <meta name="generator" content="Hugo 0.83.1" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    

  
  
    <link rel="stylesheet" href="/ananke/dist/main.css_5c99d70a7725bacd4c701e995b969fea.css" >
  




    
      

    

    
    
    <meta property="og:title" content="K8S的污点（Taints ）和容忍（Tolerations）" />
<meta property="og:description" content="节点亲和性是pod的一个属性，它将它们_吸引_到一组节点（作为首选项或硬性要求），Taints 是与之相反的，它允许节点驱逐或抵制一个pod 污点和容忍一起工作以确保不将pod安排到不适当的节点上。 将一个或多个污点应用于节点; 这标志着节点不应该接受任何不能容忍污点的pod。 容忍应用于容器，并允许（但不要求）容器安排到具有匹配的污点的节点上。 概念 使用kubectl taints为节点添加污点。例如 kubectl taint nodes node1 key=value:NoSchedule 在节点node1上放置污点。污点具有键key，值value和污点效果 NoSchedule。这意味着没有pod将能够调度到node1上，除非与pod具有匹配的容忍度。要删除上面命令添加的污点，您可以运行： kubectl taint nodes node1 key:NoSchedule- 在PodSpec中指定容器的容忍Tolerations。以下两种容忍度都“匹配”上面的kubectl污染线所产生的污点，因此具有任何容忍度的容器将能够安排到node1上：
tolerations: - key: &#34;key&#34; operator: &#34;Equal&#34; value: &#34;value&#34; effect: &#34;NoSchedule&#34; tolerations: - key: &#34;key&#34; operator: &#34;Exists&#34; effect: &#34;NoSchedule&#34; 如果key是相同的并且effect相同，则容忍和污点匹配，并且：  operator是Exists（在这种情况下不应指定key），或  operator是Equal，值相等   如果未指定，则operator默认为Equal。 **两种特殊情况： **
 带有operator Exists的空键匹配所有key，value和effect，这意味着它将容忍所有内容。   tolerations: - operator: &#34;Exists&#34;  空effect使用key:key匹配所有effect。   tolerations: - key: &#34;key&#34; operator: &#34;Exists&#34; 上面的例子使用了NoSchedule的effect。或者，您可以使用PreferNoSchedule的效果。这是NoSchedule的“首选”或“软”版本 - 系统将尽量避免放置不能容忍节点上污点的pod，但这不是必需的。第三种效果是NoExecute，稍后描述。 您可以在同一节点上放置多个污点，并在同一个pod上放置多个容差。Kubernetes处理多个污点和容忍的方式就像一个过滤器：从所有节点的污点开始，然后忽略pod具有匹配容忍度的那些;剩下的未被忽视的污点对吊舱有明显的影响。特别是  如果至少有一个未被忽略的污点具有效果NoSchedule，那么Kubernetes将不会将pod安排到该节点上  如果没有未被忽略的污点，效果NoSchedule，但至少有一个未被忽略的污点有效PreferNoSchedule然后Kubernetes将尝试不将pod安排到节点  如果存在至少一个具有effect** ** **NoExecute**的未被忽略的污点，则该pod将从该节点逐出（如果它已经在该节点上运行），并且将不会被调度到该节点上（如果它尚未在该节点上运行）。   例如，假设您的节点有这样的污点： kubectl taint nodes node1 key1=value1:NoSchedule kubectl taint nodes node1 key1=value1:NoExecute kubectl taint nodes node1 key2=value2:NoSchedule pod有两种容忍度： tolerations: - key: &#34;key1&#34; operator: &#34;Equal&#34; value: &#34;value1&#34; effect: &#34;NoSchedule&#34; - key: &#34;key1&#34; operator: &#34;Equal&#34; value: &#34;value1&#34; effect: &#34;NoExecute&#34; 在这种情况下，pod将无法安排到节点上，因为没有容忍匹配第三种污点。但是，如果在添加污点时pod已经在节点上运行，它将能够继续运行，因为第三种污点是容器中不能容忍的三种污染中唯一的一种。（pod可以容忍node1有污点 key1=value1:NoSchedule和key1=value1:NoExecute，但是不容忍key2=value2:NoSchedule，但是key2的effect为NoSchedule，意味着在添加污点的时候如果pod已经在该node运行，则不采取处理。如果没有在该node运行，将不会调度到该节点。如果污点 key2=value2:NoExecute，pod容忍不变，那么即使已经在该node运行，添加了该污点后，pod也会被驱逐） 通常情况下，如果将一个带有NoExecute效果的污点添加到一个节点，那么任何不能容忍污染的pod都会立即被驱逐，任何容忍污染的pod都不会被驱逐。但是，对NoExecute效果的容忍可以指定一个可选的tolerationSeconds字段，该字段指示在添加污点后pod将保持绑定到节点的时间。例如， tolerations: - key: &#34;key1&#34; operator: &#34;Equal&#34; value: &#34;value1&#34; effect: &#34;NoExecute&#34; tolerationSeconds: 3600 意味着如果此pod正在运行并且将匹配的污点添加到节点，则pod将保持绑定到该节点3600秒，然后被逐出。如果在此之前删除了污点，则不会驱逐pod。 另外一个pod会被默认添加一个Tolerations： 以上的Tolerations意味着：如果node的状态处于not_ready状态超过5分钟，那么该pod将不能在node上继续执行，将被驱逐。 附注： kubernetes节点失效后pod的调度过程 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/post/1583929/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2019-04-28T03:45:40&#43;00:00" />
<meta property="article:modified_time" content="2019-04-28T03:45:40&#43;00:00" />

<meta itemprop="name" content="K8S的污点（Taints ）和容忍（Tolerations）">
<meta itemprop="description" content="节点亲和性是pod的一个属性，它将它们_吸引_到一组节点（作为首选项或硬性要求），Taints 是与之相反的，它允许节点驱逐或抵制一个pod 污点和容忍一起工作以确保不将pod安排到不适当的节点上。 将一个或多个污点应用于节点; 这标志着节点不应该接受任何不能容忍污点的pod。 容忍应用于容器，并允许（但不要求）容器安排到具有匹配的污点的节点上。 概念 使用kubectl taints为节点添加污点。例如 kubectl taint nodes node1 key=value:NoSchedule 在节点node1上放置污点。污点具有键key，值value和污点效果 NoSchedule。这意味着没有pod将能够调度到node1上，除非与pod具有匹配的容忍度。要删除上面命令添加的污点，您可以运行： kubectl taint nodes node1 key:NoSchedule- 在PodSpec中指定容器的容忍Tolerations。以下两种容忍度都“匹配”上面的kubectl污染线所产生的污点，因此具有任何容忍度的容器将能够安排到node1上：
tolerations: - key: &#34;key&#34; operator: &#34;Equal&#34; value: &#34;value&#34; effect: &#34;NoSchedule&#34; tolerations: - key: &#34;key&#34; operator: &#34;Exists&#34; effect: &#34;NoSchedule&#34; 如果key是相同的并且effect相同，则容忍和污点匹配，并且：  operator是Exists（在这种情况下不应指定key），或  operator是Equal，值相等   如果未指定，则operator默认为Equal。 **两种特殊情况： **
 带有operator Exists的空键匹配所有key，value和effect，这意味着它将容忍所有内容。   tolerations: - operator: &#34;Exists&#34;  空effect使用key:key匹配所有effect。   tolerations: - key: &#34;key&#34; operator: &#34;Exists&#34; 上面的例子使用了NoSchedule的effect。或者，您可以使用PreferNoSchedule的效果。这是NoSchedule的“首选”或“软”版本 - 系统将尽量避免放置不能容忍节点上污点的pod，但这不是必需的。第三种效果是NoExecute，稍后描述。 您可以在同一节点上放置多个污点，并在同一个pod上放置多个容差。Kubernetes处理多个污点和容忍的方式就像一个过滤器：从所有节点的污点开始，然后忽略pod具有匹配容忍度的那些;剩下的未被忽视的污点对吊舱有明显的影响。特别是  如果至少有一个未被忽略的污点具有效果NoSchedule，那么Kubernetes将不会将pod安排到该节点上  如果没有未被忽略的污点，效果NoSchedule，但至少有一个未被忽略的污点有效PreferNoSchedule然后Kubernetes将尝试不将pod安排到节点  如果存在至少一个具有effect** ** **NoExecute**的未被忽略的污点，则该pod将从该节点逐出（如果它已经在该节点上运行），并且将不会被调度到该节点上（如果它尚未在该节点上运行）。   例如，假设您的节点有这样的污点： kubectl taint nodes node1 key1=value1:NoSchedule kubectl taint nodes node1 key1=value1:NoExecute kubectl taint nodes node1 key2=value2:NoSchedule pod有两种容忍度： tolerations: - key: &#34;key1&#34; operator: &#34;Equal&#34; value: &#34;value1&#34; effect: &#34;NoSchedule&#34; - key: &#34;key1&#34; operator: &#34;Equal&#34; value: &#34;value1&#34; effect: &#34;NoExecute&#34; 在这种情况下，pod将无法安排到节点上，因为没有容忍匹配第三种污点。但是，如果在添加污点时pod已经在节点上运行，它将能够继续运行，因为第三种污点是容器中不能容忍的三种污染中唯一的一种。（pod可以容忍node1有污点 key1=value1:NoSchedule和key1=value1:NoExecute，但是不容忍key2=value2:NoSchedule，但是key2的effect为NoSchedule，意味着在添加污点的时候如果pod已经在该node运行，则不采取处理。如果没有在该node运行，将不会调度到该节点。如果污点 key2=value2:NoExecute，pod容忍不变，那么即使已经在该node运行，添加了该污点后，pod也会被驱逐） 通常情况下，如果将一个带有NoExecute效果的污点添加到一个节点，那么任何不能容忍污染的pod都会立即被驱逐，任何容忍污染的pod都不会被驱逐。但是，对NoExecute效果的容忍可以指定一个可选的tolerationSeconds字段，该字段指示在添加污点后pod将保持绑定到节点的时间。例如， tolerations: - key: &#34;key1&#34; operator: &#34;Equal&#34; value: &#34;value1&#34; effect: &#34;NoExecute&#34; tolerationSeconds: 3600 意味着如果此pod正在运行并且将匹配的污点添加到节点，则pod将保持绑定到该节点3600秒，然后被逐出。如果在此之前删除了污点，则不会驱逐pod。 另外一个pod会被默认添加一个Tolerations： 以上的Tolerations意味着：如果node的状态处于not_ready状态超过5分钟，那么该pod将不能在node上继续执行，将被驱逐。 附注： kubernetes节点失效后pod的调度过程 1."><meta itemprop="datePublished" content="2019-04-28T03:45:40&#43;00:00" />
<meta itemprop="dateModified" content="2019-04-28T03:45:40&#43;00:00" />
<meta itemprop="wordCount" content="157">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="K8S的污点（Taints ）和容忍（Tolerations）"/>
<meta name="twitter:description" content="节点亲和性是pod的一个属性，它将它们_吸引_到一组节点（作为首选项或硬性要求），Taints 是与之相反的，它允许节点驱逐或抵制一个pod 污点和容忍一起工作以确保不将pod安排到不适当的节点上。 将一个或多个污点应用于节点; 这标志着节点不应该接受任何不能容忍污点的pod。 容忍应用于容器，并允许（但不要求）容器安排到具有匹配的污点的节点上。 概念 使用kubectl taints为节点添加污点。例如 kubectl taint nodes node1 key=value:NoSchedule 在节点node1上放置污点。污点具有键key，值value和污点效果 NoSchedule。这意味着没有pod将能够调度到node1上，除非与pod具有匹配的容忍度。要删除上面命令添加的污点，您可以运行： kubectl taint nodes node1 key:NoSchedule- 在PodSpec中指定容器的容忍Tolerations。以下两种容忍度都“匹配”上面的kubectl污染线所产生的污点，因此具有任何容忍度的容器将能够安排到node1上：
tolerations: - key: &#34;key&#34; operator: &#34;Equal&#34; value: &#34;value&#34; effect: &#34;NoSchedule&#34; tolerations: - key: &#34;key&#34; operator: &#34;Exists&#34; effect: &#34;NoSchedule&#34; 如果key是相同的并且effect相同，则容忍和污点匹配，并且：  operator是Exists（在这种情况下不应指定key），或  operator是Equal，值相等   如果未指定，则operator默认为Equal。 **两种特殊情况： **
 带有operator Exists的空键匹配所有key，value和effect，这意味着它将容忍所有内容。   tolerations: - operator: &#34;Exists&#34;  空effect使用key:key匹配所有effect。   tolerations: - key: &#34;key&#34; operator: &#34;Exists&#34; 上面的例子使用了NoSchedule的effect。或者，您可以使用PreferNoSchedule的效果。这是NoSchedule的“首选”或“软”版本 - 系统将尽量避免放置不能容忍节点上污点的pod，但这不是必需的。第三种效果是NoExecute，稍后描述。 您可以在同一节点上放置多个污点，并在同一个pod上放置多个容差。Kubernetes处理多个污点和容忍的方式就像一个过滤器：从所有节点的污点开始，然后忽略pod具有匹配容忍度的那些;剩下的未被忽视的污点对吊舱有明显的影响。特别是  如果至少有一个未被忽略的污点具有效果NoSchedule，那么Kubernetes将不会将pod安排到该节点上  如果没有未被忽略的污点，效果NoSchedule，但至少有一个未被忽略的污点有效PreferNoSchedule然后Kubernetes将尝试不将pod安排到节点  如果存在至少一个具有effect** ** **NoExecute**的未被忽略的污点，则该pod将从该节点逐出（如果它已经在该节点上运行），并且将不会被调度到该节点上（如果它尚未在该节点上运行）。   例如，假设您的节点有这样的污点： kubectl taint nodes node1 key1=value1:NoSchedule kubectl taint nodes node1 key1=value1:NoExecute kubectl taint nodes node1 key2=value2:NoSchedule pod有两种容忍度： tolerations: - key: &#34;key1&#34; operator: &#34;Equal&#34; value: &#34;value1&#34; effect: &#34;NoSchedule&#34; - key: &#34;key1&#34; operator: &#34;Equal&#34; value: &#34;value1&#34; effect: &#34;NoExecute&#34; 在这种情况下，pod将无法安排到节点上，因为没有容忍匹配第三种污点。但是，如果在添加污点时pod已经在节点上运行，它将能够继续运行，因为第三种污点是容器中不能容忍的三种污染中唯一的一种。（pod可以容忍node1有污点 key1=value1:NoSchedule和key1=value1:NoExecute，但是不容忍key2=value2:NoSchedule，但是key2的effect为NoSchedule，意味着在添加污点的时候如果pod已经在该node运行，则不采取处理。如果没有在该node运行，将不会调度到该节点。如果污点 key2=value2:NoExecute，pod容忍不变，那么即使已经在该node运行，添加了该污点后，pod也会被驱逐） 通常情况下，如果将一个带有NoExecute效果的污点添加到一个节点，那么任何不能容忍污染的pod都会立即被驱逐，任何容忍污染的pod都不会被驱逐。但是，对NoExecute效果的容忍可以指定一个可选的tolerationSeconds字段，该字段指示在添加污点后pod将保持绑定到节点的时间。例如， tolerations: - key: &#34;key1&#34; operator: &#34;Equal&#34; value: &#34;value1&#34; effect: &#34;NoExecute&#34; tolerationSeconds: 3600 意味着如果此pod正在运行并且将匹配的污点添加到节点，则pod将保持绑定到该节点3600秒，然后被逐出。如果在此之前删除了污点，则不会驱逐pod。 另外一个pod会被默认添加一个Tolerations： 以上的Tolerations意味着：如果node的状态处于not_ready状态超过5分钟，那么该pod将不能在node上继续执行，将被驱逐。 附注： kubernetes节点失效后pod的调度过程 1."/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        My New Hugo Site
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      




  <div id="sharing" class="mt3">

    
    <a href="https://www.facebook.com/sharer.php?u=http://example.org/post/1583929/" class="facebook no-underline" aria-label="share on Facebook">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765,50.32h6.744V33.998h4.499l0.596-5.624h-5.095  l0.007-2.816c0-1.466,0.14-2.253,2.244-2.253h2.812V17.68h-4.5c-5.405,0-7.307,2.729-7.307,7.317v3.377h-3.369v5.625h3.369V50.32z   M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;"/></svg>

    </a>

    
    
    <a href="https://twitter.com/share?url=http://example.org/post/1583929/&amp;text=K8S%e7%9a%84%e6%b1%a1%e7%82%b9%ef%bc%88Taints%20%ef%bc%89%e5%92%8c%e5%ae%b9%e5%bf%8d%ef%bc%88Tolerations%ef%bc%89" class="twitter no-underline" aria-label="share on Twitter">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167,22.283c-2.619,0.953-4.274,3.411-4.086,6.101  l0.063,1.038l-1.048-0.127c-3.813-0.487-7.145-2.139-9.974-4.915l-1.383-1.377l-0.356,1.017c-0.754,2.267-0.272,4.661,1.299,6.271  c0.838,0.89,0.649,1.017-0.796,0.487c-0.503-0.169-0.943-0.296-0.985-0.233c-0.146,0.149,0.356,2.076,0.754,2.839  c0.545,1.06,1.655,2.097,2.871,2.712l1.027,0.487l-1.215,0.021c-1.173,0-1.215,0.021-1.089,0.467  c0.419,1.377,2.074,2.839,3.918,3.475l1.299,0.444l-1.131,0.678c-1.676,0.976-3.646,1.526-5.616,1.568  C19.775,43.256,19,43.341,19,43.405c0,0.211,2.557,1.397,4.044,1.864c4.463,1.377,9.765,0.783,13.746-1.568  c2.829-1.673,5.657-5,6.978-8.221c0.713-1.716,1.425-4.851,1.425-6.354c0-0.975,0.063-1.102,1.236-2.267  c0.692-0.678,1.341-1.419,1.467-1.631c0.21-0.403,0.188-0.403-0.88-0.043c-1.781,0.636-2.033,0.551-1.152-0.402  c0.649-0.678,1.425-1.907,1.425-2.267c0-0.063-0.314,0.042-0.671,0.233c-0.377,0.212-1.215,0.53-1.844,0.72l-1.131,0.361l-1.027-0.7  c-0.566-0.381-1.361-0.805-1.781-0.932C39.766,21.902,38.131,21.944,37.167,22.283z M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4  s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/></svg>

    </a>

    
    <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http://example.org/post/1583929/&amp;title=K8S%e7%9a%84%e6%b1%a1%e7%82%b9%ef%bc%88Taints%20%ef%bc%89%e5%92%8c%e5%ae%b9%e5%bf%8d%ef%bc%88Tolerations%ef%bc%89" class="linkedin no-underline" aria-label="share on LinkedIn">
      <svg  height="32px"  style="enable-background:new 0 0 65 65;" version="1.1" viewBox="0 0 65 65" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <path d="M50.837,48.137V36.425c0-6.275-3.35-9.195-7.816-9.195  c-3.604,0-5.219,1.983-6.119,3.374V27.71h-6.79c0.09,1.917,0,20.427,0,20.427h6.79V36.729c0-0.609,0.044-1.219,0.224-1.655  c0.49-1.22,1.607-2.483,3.482-2.483c2.458,0,3.44,1.873,3.44,4.618v10.929H50.837z M22.959,24.922c2.367,0,3.842-1.57,3.842-3.531  c-0.044-2.003-1.475-3.528-3.797-3.528s-3.841,1.524-3.841,3.528c0,1.961,1.474,3.531,3.753,3.531H22.959z M34,64  C17.432,64,4,50.568,4,34C4,17.431,17.432,4,34,4s30,13.431,30,30C64,50.568,50.568,64,34,64z M26.354,48.137V27.71h-6.789v20.427  H26.354z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>

    </a>
  </div>


      <h1 class="f1 athelas mt3 mb1">K8S的污点（Taints ）和容忍（Tolerations）</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2019-04-28T03:45:40Z">April 28, 2019</time>

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><p>节点亲和性是pod的一个属性，它将它们_吸引_到一组节点（作为首选项或硬性要求），Taints 是与之相反的，它允许节点驱逐或抵制一个pod  <!-- raw HTML omitted -->污点和容忍一起工作以确保不将pod安排到不适当的节点上。 将一个或多个污点应用于节点; 这标志着节点不应该接受任何不能容忍污点的pod。 容忍应用于容器，并允许（但不要求）容器安排到具有匹配的污点的节点上。
<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h2 id="概念">概念</h2>
<p>使用<code>kubectl taints</code>为节点添加污点。例如  </p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl taint nodes node1 key<span style="color:#f92672">=</span>value:NoSchedule
</code></pre></div><p>在节点node1上放置污点。污点具有键<strong>key</strong>，值<strong>value</strong>和污点效果 <strong>NoSchedule</strong>。这意味着没有pod将能够调度到node1上，除非与pod具有匹配的容忍度。要删除上面命令添加的污点，您可以运行： </p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl taint nodes node1 key:NoSchedule-
</code></pre></div><p>在PodSpec中指定容器的容忍Tolerations。以下两种容忍度都“匹配”上面的kubectl污染线所产生的污点，因此具有任何容忍度的容器将能够安排到node1上：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">tolerations</span>:
- <span style="color:#f92672">key</span>: <span style="color:#e6db74">&#34;key&#34;</span>
  <span style="color:#f92672">operator</span>: <span style="color:#e6db74">&#34;Equal&#34;</span>
  <span style="color:#f92672">value</span>: <span style="color:#e6db74">&#34;value&#34;</span>
  <span style="color:#f92672">effect</span>: <span style="color:#e6db74">&#34;NoSchedule&#34;</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">tolerations</span>:
- <span style="color:#f92672">key</span>: <span style="color:#e6db74">&#34;key&#34;</span>
  <span style="color:#f92672">operator</span>: <span style="color:#e6db74">&#34;Exists&#34;</span>
  <span style="color:#f92672">effect</span>: <span style="color:#e6db74">&#34;NoSchedule&#34;</span>
</code></pre></div><p>如果<strong>key</strong>是相同的并且<strong>effect</strong>相同，则容忍和污点匹配，并且：  </p>
<ul>
<li><strong>operator</strong>是<strong>Exists</strong>（在这种情况下不应指定<strong>key</strong>），或  </li>
<li><strong>operator</strong>是<strong>Equal</strong>，值相等  </li>
</ul>
<p>如果未指定，则<strong>operator</strong>默认为<strong>Equal</strong>。  <!-- raw HTML omitted -->**两种特殊情况：  **</p>
<ul>
<li>带有<strong>operator   Exists</strong>的空键匹配所有<strong>key</strong>，<strong>value</strong>和<strong>effect</strong>，这意味着它将容忍所有内容。 </li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">tolerations</span>:
- <span style="color:#f92672">operator</span>: <span style="color:#e6db74">&#34;Exists&#34;</span>
</code></pre></div><ul>
<li>空<strong>effect</strong>使用<strong>key:key</strong>匹配所有<strong>effect</strong>。  </li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">tolerations</span>:
- <span style="color:#f92672">key</span>: <span style="color:#e6db74">&#34;key&#34;</span>
  <span style="color:#f92672">operator</span>: <span style="color:#e6db74">&#34;Exists&#34;</span>
</code></pre></div><p>上面的例子使用了<strong>NoSchedule</strong>的<strong>effect</strong>。或者，您可以使用PreferNoSchedule的效果。这是NoSchedule的“首选”或“软”版本 - 系统将尽量避免放置不能容忍节点上污点的pod，但这不是必需的。第三种效果是NoExecute，稍后描述。  <!-- raw HTML omitted -->您可以在同一节点上放置多个污点，并在同一个pod上放置多个容差。Kubernetes处理多个污点和容忍的方式就像一个过滤器：从所有节点的污点开始，然后忽略pod具有匹配容忍度的那些;剩下的未被忽视的污点对吊舱有明显的影响。特别是  </p>
<ul>
<li>如果至少有一个未被忽略的污点具有效果<strong>NoSchedule</strong>，那么Kubernetes将不会将pod安排到该节点上  </li>
<li>如果没有未被忽略的污点，效果NoSchedule，但至少有一个未被忽略的污点有效PreferNoSchedule然后Kubernetes将尝试不将pod安排到节点  </li>
<li>如果存在至少一个具有effect** ** **NoExecute**的未被忽略的污点，则该pod将从该节点逐出（如果它已经在该节点上运行），并且将不会被调度到该节点上（如果它尚未在该节点上运行）。   </li>
</ul>
<p>例如，假设您的节点有这样的污点：  </p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl taint nodes node1 key1<span style="color:#f92672">=</span>value1:NoSchedule
kubectl taint nodes node1 key1<span style="color:#f92672">=</span>value1:NoExecute
kubectl taint nodes node1 key2<span style="color:#f92672">=</span>value2:NoSchedule
</code></pre></div><p>pod有两种容忍度：  </p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">tolerations</span>:
- <span style="color:#f92672">key</span>: <span style="color:#e6db74">&#34;key1&#34;</span>
  <span style="color:#f92672">operator</span>: <span style="color:#e6db74">&#34;Equal&#34;</span>
  <span style="color:#f92672">value</span>: <span style="color:#e6db74">&#34;value1&#34;</span>
  <span style="color:#f92672">effect</span>: <span style="color:#e6db74">&#34;NoSchedule&#34;</span>
- <span style="color:#f92672">key</span>: <span style="color:#e6db74">&#34;key1&#34;</span>
  <span style="color:#f92672">operator</span>: <span style="color:#e6db74">&#34;Equal&#34;</span>
  <span style="color:#f92672">value</span>: <span style="color:#e6db74">&#34;value1&#34;</span>
  <span style="color:#f92672">effect</span>: <span style="color:#e6db74">&#34;NoExecute&#34;</span>
</code></pre></div><p>在这种情况下，pod将无法安排到节点上，因为没有容忍匹配第三种污点。但是，如果在添加污点时pod已经在节点上运行，它将能够继续运行，因为第三种污点是容器中不能容忍的三种污染中唯一的一种。（pod可以容忍node1有污点 key1=value1:NoSchedule和key1=value1:NoExecute，但是不容忍key2=value2:NoSchedule，但是key2的effect为<strong>NoSchedule，<strong>意味着在添加污点的时候如果pod已经在该node运行，则不采取处理。如果没有在该node运行，将不会调度到该节点。如果污点 key2=value2:NoExecute，pod容忍不变，那么即使已经在该node运行，添加了该污点后，pod也会被驱逐）  <!-- raw HTML omitted -->通常情况下，如果将一个带有</strong>NoExecute</strong>效果的污点添加到一个节点，那么任何不能容忍污染的pod都会立即被驱逐，任何容忍污染的<strong>pod</strong>都不会被驱逐。但是，对<strong>NoExecute</strong>效果的容忍可以指定一个可选的<strong>tolerationSeconds</strong>字段，该字段指示在添加污点后pod将保持绑定到节点的时间。例如，  </p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">tolerations</span>:
- <span style="color:#f92672">key</span>: <span style="color:#e6db74">&#34;key1&#34;</span>
  <span style="color:#f92672">operator</span>: <span style="color:#e6db74">&#34;Equal&#34;</span>
  <span style="color:#f92672">value</span>: <span style="color:#e6db74">&#34;value1&#34;</span>
  <span style="color:#f92672">effect</span>: <span style="color:#e6db74">&#34;NoExecute&#34;</span>
  <span style="color:#f92672">tolerationSeconds</span>: <span style="color:#ae81ff">3600</span>
</code></pre></div><p>意味着如果此pod正在运行并且将匹配的污点添加到节点，则pod将保持绑定到该节点3600秒，然后被逐出。如果在此之前删除了污点，则不会驱逐pod。  <!-- raw HTML omitted -->另外一个pod会被默认添加一个<strong>Tolerations</strong>：  <!-- raw HTML omitted --><img src="/images/1583929_1.png" alt="image.png"><!-- raw HTML omitted -->以上的<strong>Tolerations</strong>意味着：如果node的状态处于not_ready状态超过5分钟，那么该pod将不能在node上继续执行，将被驱逐。 <!-- raw HTML omitted -->附注：  </p>
<pre><code>kubernetes节点失效后pod的调度过程
1.Master每隔一段时间和node联系一次，判定node是否失联，这个时间周期配置项为 node-monitor-period ，默认5s
2.当node失联后一段时间后，kubernetes判定node为notready状态，这段时长的配置项为 node-monitor-grace-period ，默认40s
3.当node失联后一段时间后，kubernetes判定node为unhealthy，这段时长的配置项为 node-startup-grace-period ，默认1m0s
4.当node失联后一段时间后，kubernetes开始删除原node上的pod，这段时长配置项为 pod-eviction-timeout ，默认5m0s
在应用中，想要缩短pod的重启时间，可以修改上述几个参数
</code></pre><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h2 id="基于污点的驱逐">基于污点的驱逐</h2>
<p>之前我们提到过NoExecute污染效果，它会影响已经在节点上运行的pod，如下所示  </p>
<ul>
<li>不能容忍污染的pod立即被驱逐  </li>
<li>容忍污点而没有在容忍规范中指定tolerationSeconds的pod仍然被绑定到该节点的（如ds）  </li>
<li>容忍具有指定容忍度的污点的容器在指定的时间内保持绑定  </li>
</ul>
<p>此外，Kubernetes 1.6引入了alpha支持来表示节点问题。换句话说，当某些条件为真时，节点控制器自动污染节点。内置以下污点：  </p>
<ul>
<li>**node.kubernetes.io/not-ready：**节点尚未就绪。这对应于NodeCondition Ready为“False”。</li>
<li>**node.kubernetes.io/unreachable：**节点控制器无法访问节点。这对应于NodeCondition Ready为“Unknown”。  </li>
<li>**node.kubernetes.io/out-of-disk：**节点变得磁盘不足</li>
<li>**node.kubernetes.io/memory-pressure：**节点有内存压力</li>
<li>**node.kubernetes.io/disk-pressure：**节点有磁盘压力</li>
<li>**node.kubernetes.io/network-unavailable：**节点的网络不可用</li>
<li>**node.kubernetes.io/unschedulable：**节点是不可调度的</li>
<li>**node.cloudprovider.kubernetes.io/uninitialized：**当使用“外部”云提供程序启动kubelet时，会在节点上设置此污点以将其标记为不可用。在cloud-controller-manager的控制器初始化此节点后，kubelet将删除此污点。</li>
</ul>
<p>在版本1.13中，<strong>TaintBasedEvictions</strong>功能被提升为beta并默认启用，因此NodeController（或kubelet）会自动添加taints，并且禁用基于Ready NodeCondition从节点驱逐pod的常规逻辑。  </p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://example.org/" >
    &copy;  My New Hugo Site 2021 
  </a>
    <div>














</div>
  </div>
</footer>

  </body>
</html>
